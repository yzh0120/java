将具体的类型参数化(形参化,模糊化),在调用的时候具体化的类型
泛型可用在 类 方法 接口中  -->  泛型类  泛型方法  泛型接口

泛型定义格式:
<类型一> 指定一种格式的泛型,这里的类型可以看成形参
<类型一,类型二>指定多种类型的泛型
将来具体调用的时候可以看成实参 ,并且实参的类型只能是引用数据类型
------------------------------------------------------------------
泛型类定义格式:
修饰符 class  类名<类型>{
	
}

public class Demo<T>{//T是随便写的任意标识  T E K V 常用于标识泛型
	private T age;
}

public class Demo<T>{
	public void show(T t){
		
	}
}
------------------------------------------------------------------
泛型方法(是不是泛型类没有关系)
public class Demo{
	public <T> void show(T t){
		
	}
}
------------------------------------------------------------------
泛型接口
修饰符 interface  接口名<类型>{
	
}
实现类
public class 实现类名<T> implements 接口名<T>{
	
} 
------------------------------------------------------------------
类型通配符 <?>
List<?> 表示元素类型位置的List,它的元素可以匹配任何的类型
这种带通配符的List仅表示它是各种泛型的父类,并不能把元素添加到其中
如果说我们不希望List<?>是任何泛型的父类,只希望它代表某一类泛型的父类,可以使用类型通配符的上限
<? extends 类型>  <? extends Number> : 它表示的类型是Number或者其子类型

通配符的下限
<? super 类型>    <? super Number> : 它表示的类型是Number或者其父类型